
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The most basic go concurrency programming question stumped 90% of candidates</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>The most basic go concurrency programming question stumped 90% of candidates</h1>
        <h2>最基础的 go 并发编程题，难倒了 90%的候选人</h2>
        <div class="content">
            <p>Two goroutines communicate using channels. One goroutine sequentially sends the numbers 0, 1, 2, 3, 4, and the other goroutine receives and outputs them.
The question examines basic knowledge such as goroutine control and channel closing. The code written by interviewees had various problems.

1. Some goroutines exited before the program even started. After being prompted, they still didn't think of using waitgroup, context, done channel, etc., but instead used time sleep to wait;
2. Some didn't know that the channel should be closed by the producer, and directly closed it before the producer in the main program finished sending, resulting in a panic;
3. Some didn't check the return value of the consumer reading a closed channel, causing the program to directly enter an infinite loop and deadlock.

Last week, I interviewed 5 people, and only 1 person wrote code that executed without problems on the first try. 1 person couldn't write it even after being prompted. The rest could gradually modify it into correct code after being prompted.

This question is still very classic. Instead of asking about GMP, garbage collection algorithms, and other rote memorization, this question can reveal the candidate's Go fundamentals.</p>
            <p>两个 goroutine 用 channel 通信，一个 goroutine 顺序发送 0,1,2,3,4 个数字，另一个 goroutine 接收并输出。
考察了 goroutine 的控制、channel 的关闭等基础知识，面试者写的代码各种问题。

1. 有的 goroutine 还没启动程序就退出了，提示后仍想不到使用 waitgroup ，context ，done channel 等手段，而是用 time sleep 等待；
2. 有的 channel 不知道由生产者关闭，直接在主程序生产者还未发送结束就关闭结果 panic ；
3. 有的不会检查消费者读关闭 channel 的返回值，程序直接死循环死锁。

上周面试 5 个人只有 1 个人一次写出了执行没问题的代码，有 1 个经过提示也没写出来，剩下的能提示后逐步修改出正确的代码。

这个题还是很经典的，不用问 GMP 、垃圾回收算法等八股文，这个题就能看出 go 基础了。</p>
        </div>
        <div class="replies">
            <h3>评论</h3>
            <ul>
                <li>Fishing addiction is a disease and needs to be treated<br>钓鱼上瘾是病，得治</li><li>Just took a look, you also posted the "Is it difficult to give an LRU algorithm question in the first interview?" thread last week. What type of position are you responsible for interviewing for? Why is there such a big gap in the questions? And to be honest, if 80% of the people who submit resumes to you don't even understand the basics of chan... then it's inappropriate to ask about LRU during the interview for this position.<br>看了一下，上周那个 “一面出 LRU 算法题算难吗” 的帖子也是你发的。老哥你负责面的到底是什么类型岗位呀？怎么题目差距好像有点儿大。而且说实话，如果给你投简历的人里面，有 80%连 chan 的基础都用不清楚。。。那么你这个岗位面试的时候应该不适合问 LRU 。</li><li>How much is the salary? If the salary is low, then it's a "fair match", which is good.<br>薪资给多少？薪资低那就 “门当户对” 了，挺好的。</li><li>Don't have unexplained superiority and then collect copper coins when you get old; first screen with pragmatic standards, such as a full-time bachelor's degree, CET-4/6, 3 years of experience, etc.<br>你也别有莫名的优越感然后老来收铜币；先用务实标准筛选一下吧，统招本科四六级，3 年经验之类的</li><li>It can only be said that the OP is recruiting in the wrong direction. The 985 and 211 graduates you are recruiting are not lacking in interview opportunities in the market. If they don't particularly love code, they won't delve into these things. Anyway, CRUD can easily earn money, so why not play games after work? On the other hand, some of those with lower educational qualifications, such as junior college and ordinary undergraduate degrees, may actually delve into these things in order to stand out in the competition, but the smart OP has already filtered out this possibility. Therefore, isn't it normal that 90% of the interviewees don't know?<br>只能说 op 招聘错方向了，你招的 985 ，211 都是市场里不缺面试机会的那一批。如果不是特别热爱代码的，也不会去钻研这些东西，反正 curd 就能轻松把钱拿，下班了打游戏不香吗。倒是那些学历低人一等的大专和普本，有少部分人为了在竞争中脱颖而出，可能真会去钻研这种东西，而聪明的 op 已经把这种可能性过滤掉了。至此，面试者百分之 90%不会不是很正常吗</li><li>I have to point out that the candidates really have a problem, this, this is completely clueless...<br>拿我得指出哥们候选人真的有问题吧, 这, 这不是完全不会嘛...</li><li>I also ask this question in interviews. I feel it's related to HR. Many HR only look at background and don't understand technology. They bring a bunch of people over, and 90% can't write the code. The HR here is more professional, and basically half of the people can write it. It's funny to think that these people who can't even write basic coroutine communication can talk about garbage collection, array expansion, and optimistic/pessimistic locking fluently.<br>我面试也问这个题目。感觉和 hr 相关，很多 hr 只看背景，不懂技术，找一堆人过来就 90%都写不出来。我现在这里 hr 比较专业，基本上一半的人能写出来的。想来也是搞笑，这些连个协程通信都写不明白的人，讲起垃圾回收，数组扩容，乐观锁悲观锁却能头头是道</li><li>time.sleep……<br>time.sleep……</li><li>If we define the difficulty of the question from the perspective of the pass rate distribution, 90% should be considered hard.<br>如果说从通过率分布的角度来定义 题的难度的话 90% 应该算 hard</li><li>Although I know I should use waitgroup, doesn't "time sleep" solve the problem of exiting before the execution is complete?<br>虽然知道应该使用 waitgroup ，但是， "time sleep " 没解决没执行完就退出这个问题么？</li><li>This is not called go fundamentals, it's just programming fundamentals.<br>你这个不叫 go 基础，就是个编程基础。</li><li>Can I use a third-party library? My brain has been spoiled by conc, and I only remember conc's WaitGroup. The system's WaitGroup seems to belong to the sync package.<br>可以用第三方库不，我脑子已经被 conc 惯坏了，只记得起 conc 的 WaitGroup ， 系统的 WaitGroup  好像属于 sync 包。</li><li>Isn't concurrency the essence of Golang? If you haven't mastered this, it's like you haven't learned it.<br>golang 的精髓不就是并发吗？这都没掌握，等于没学</li><li>@fruitmonster time sleep only reduces the probability of this problem occurring, it does not solve the problem. If the operation is requesting an API or some other time-consuming operation, how long should you sleep? This method is not good, you still need to use wait group or other methods to synchronize.<br>@fruitmonster time sleep 只是降低出现这个问题的概率，并没有解决问题。如果操作是请求 api 或者其他耗时操作，要 sleep 多久？这种方式不好的，还是得 wait group 或者其他方式来同步</li><li>This situation at least shows that they have never done a program that requires graceful shutdown. It can't be said to be a death sentence, but at least they don't know much about Go.<br>这种情况至少说明完全没做过需要 graceful shutdown 的程序，不能说判死刑，但至少对 go 不太了解吧</li><li>Can you talk about how many years of experience the job requires and how much salary is offered?<br>可以说说招聘岗位要求几年经验，给多少薪资</li><li>package mainimport "fmt"func main() {    // Create an unbuffered channel    ch := make(chan int)    // Sender goroutine    go func() {        for i := 0; i < 5; i++ {            ch <- i  // Send numbers sequentially        }        close(ch)  // Close the channel after sending [1,7](@ref)    }()    // Receiver goroutine    for num := range ch {        fmt.Println("Received:", num)    }} Is this correct?<br>package mainimport "fmt"func main() {    // 创建无缓冲通道    ch := make(chan int)    // 发送方 goroutine    go func() {        for i := 0; i < 5; i++ {            ch <- i  // 顺序发送数字        }        close(ch)  // 发送完成后关闭通道[1,7](@ref)    }()    // 接收方 goroutine    for num := range ch {        fmt.Println("Received:", num)    }}这个对吗</li><li>Posting these things every day, are you trying to switch to self-media?<br>天天发这些，不会是想转自媒体吧</li><li>Based on your condition, they fail the test. Conversely, if they ask you questions to test you, are you confident that you will pass? A single question cannot explain a person's overall ability.<br>对于你的状态来考他们不合格，那反过来他们提问题考验你你有信心通过吗？ 单个问题并不能说明人的整体能力</li><li>package mainimport (	"fmt"	"sync")func writeData(c chan int, i int) {	c <- i}func readData(c chan int) {	for i := 0; i < 5; i++ {		fmt.Println("The data is:", <-c)	}}func main() {	var wg sync.WaitGroup	wg.Add(5)	var c = make(chan int)	for k := 1; k <= 5; k++ {		go func() {			defer wg.Done()			writeData(c, k)		}()	}	go readData(c)	wg.Wait()	close(c)}<br>package mainimport (	"fmt"	"sync")func writeData(c chan int, i int) {	c <- i}func readData(c chan int) {	for i := 0; i < 5; i++ {		fmt.Println("The data is:", <-c)	}}func main() {	var wg sync.WaitGroup	wg.Add(5)	var c = make(chan int)	for k := 1; k <= 5; k++ {		go func() {			defer wg.Done()			writeData(c, k)		}()	}	go readData(c)	wg.Wait()	close(c)}</li>
            </ul>
        </div>
    </div>
</body>
</html>
